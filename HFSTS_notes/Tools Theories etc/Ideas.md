Motto: "Humanity's search for meaning"  
  
New notes:  

Art Tools:  
- art direction defined in files  
- runtime definitions/settings  
- art generation definitions/settings  
- definitions are selected from a list of tools, which can be modified/improved by the user  
  
UI:
Graph editing:  
- graph editing should have references (like C pointers)  
- graph editing should also have tags  
- both of these together better represent how the brain works  
- when representing referenced nodes, give option to include contents or not (like a C pre processor #include)

- reveal more info about node when staring at it  
- it is part of the reason Im having a creative block when using graph editing, as opposed to text editing. Im not getting the right hints for kickstarting my imagination. So maybe consider a more general system.  
  
- visual comments?
- obviously, a folder directory provides a lot of contextual meaning to files, dont waste that information when representing files 
  
AI Assistant:  
- should be the business end of the software  
- with the help of SPECIALIZED tools of course (but avoided as much as possible)  
- the goal is to make work intuitive and natural  
- thus, a tool making pipeline (ie standard) is necessary (so a tool making tool XD )  
  
- when the AI makes a suggestion and the user denies it, that should be filed into a list of "worries" in the project meta file  
  
Old notes:  
  
Organizing, writing down and structuring your thoughts is good. This should be used to accelerate the design process.  
  
New versions should be compiled using older versions  
  
Community based research  
Programmed proof tests  
Community proposed and voted theories and models  
Singleton terminology as voted by community (!consolidation! and unification of terminology)  
Products should be able to send feedback as part of collecting statistical info  
  
Worker scripts exist to do menial tasks (such as tests)  
Scripts can be used in both the truth and the product(or anywhere)  
Utility scripts are not part of the truth, but they allow new functionality  
Every item from the truth and product can be discussed, voted on, researched...  
[https://en.m.wikipedia.org/wiki/Theory](https://en.m.wikipedia.org/wiki/Theory)  
[https://en.m.wikipedia.org/wiki/Theory_(mathematical_logic)](https://en.m.wikipedia.org/wiki/Theory_(mathematical_logic))  
  
Same meaning can be represented in different mediums  
Meaning across mediums can be corelated with the use of voting? (See equivalency tables later on)  
  
  
Statistical, math and geometric theory should probably be included as standard in the software. Others should be considered  
  
Possible item types:  
Scripts, theories, tests, terminology, data models  
  
Every server represents a truth of design  
The community of a server seeks their own truth  
Similar to github repos, truths can be many and manipulated, offline, online  
Torrent like version control/data model?  
  
Program should be designed to guide users into specific work mindsets  
  
Gamified experience  
Profiles  
Passwordless profile access  
Big UI  
Graph scripting  
Project statistics are prevalent in the software (for tracking and self improvement) (maybe provided by utility/worker scripts?)  
Percentage of components is clearly shown (background color as well as text entry in separate stat window?)  
Qualification weighted as well as equal voting
Dynamic polls where options can be added  
Different types of reactions necessary to improve vote count(thumbs up, laugh...) 

Profiles have weighted stats depending on qualification  
Team support  
  
Design file can be represented in many forms (graph/document...)  
Design file can generate a test product (game)  
  
Previous iteration of this software used to generate next iteration of this software  
Release version should be 2.0  
  
Change the way papers are written and read by encouraging reading in the intermediate format  
  
Program design must encourage interaction with casual users (for the sake of improving the quality of surveys)  
Surveys automatically take advantage of profile info ( such as age, philosophies, gender etc)  
Thus, profile info needs to be diverse and high quality  
A type of surveys should be equivalency tables (a type of hypothesis) (for associating emotions, for example)  
  
Consider a UI thats based on communication (dialog) instead of buttons and other classic UI elements (intuitive, helps with the learning curve)  
Different types of items should be color-coded  
Keep VR in consideration  
Strongly encourage AI communication, old school UI should only be used for the sake of shortcuts (like an artists pallette)  
  
Lean to centralised network first, then upgrade to decentralized later (saves time) (maybe look at github?)  
  
Use Programming language translators to make projects cross-functional
Its ok if the first (ie second) version of the software isnt dynamically edited,tested. Its ok if you have to compile and test resulting code in a different program. Rely on translators to achieve this. Like a glorified precompiler.  
  
Is it possible to create an editor using just theories, models and bots?

Maybe, freeform note taking (like on paper) is the right way to do things. Its almost perfect as far as mind flow goes. Augmenting old school freeform mind mapping with new tech is probably the best combination. As in, the tech would be complimentary.


Chase's wishlist:
- check out campfirewriting.com
- automatic (or delayed) linking of concepts
- quick templates (like a preset todo list)
- getting to the right place in your notes slowly can be a flow killer


Simplicity  
Feature Complete  
  
Feature Complete:  
Interpretation 1: Depends on the necessities of the audience  
Whats the audience?  
What are their necessities?  
  
Interpretation 2: Depends on the necessities of the models?  
What are the models  
What are their necessities?  
  
  
People that could first test HFSTS:  
Home Decorators
Cartoonists
Sculptors
Architects
Jewelrymakers
  
  
Overall design:  
Human Model affects Designs  
Capabilities limit Design  
  
Human Model }{ Product ][ Goal  
  
The Product is built to fit the User (Human Model) and aid the User in reaching their Goal  
  
Theory 1:  
The product must fit the Human Model and the Goal  
  
Theory 2:  
The different components of the Design System (1) can be rigid or fluid. There can be many reasons (2) why one would choose between the two.  
Note that this theory fits theory # 1.  
Note that elements in the System aren't binary in the rigid-fluid range. Some elements can be more fixed or dynamic than others. The System is built around and follows one rule:
	
	If element A is more fluid than element B, element A needs to concede its design to complement element B.  
  
Amendments to consider to the Fundamental Design Rule:  
1) FDR only applies when elements A and B affect each other  
2) All element relationships are bidirectional; Or mono-directional with the option to interpret the effect in reverse.  
  
(1) IE: the proposed Human Model - Design - Goal system  
(2) reasonings behind calculating the fluidity value of an element:  
	- importance